import { describe, it, expect, beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals';
import { prisma } from '../setup';
import { cleanupDatabase } from '../lib/db-test-utils';

describe('Task Model CRUD Operations', () => {
  beforeAll(async () => {
    await prisma.$connect();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  beforeEach(cleanupDatabase);

  afterEach(cleanupDatabase);

  describe('Create Task', () => {
    let caseId: string;

    beforeEach(async () => {
      const category = await prisma.caseCategory.create({
        data: {
          name: 'テストカテゴリ',
          roleDefinitions: {},
        },
      });

      const case_ = await prisma.case.create({
        data: {
          name: 'テスト事件',
          categoryId: category.id,
        },
      });
      caseId = case_.id;
    });

    it('should create a new task with required fields', async () => {
      const taskData = {
        caseId: caseId,
        description: '準備書面を作成する',
        dueDate: new Date('2024-12-31'),
        isCompleted: false,
        isAutoGenerated: false,
      };

      const task = await prisma.task.create({
        data: taskData,
      });

      expect(task).toBeDefined();
      expect(task.id).toBeDefined();
      expect(task.caseId).toBe(caseId);
      expect(task.description).toBe(taskData.description);
      expect(task.dueDate).toEqual(taskData.dueDate);
      expect(task.isCompleted).toBe(taskData.isCompleted);
      expect(task.isAutoGenerated).toBe(taskData.isAutoGenerated);
      expect(task.assignedToId).toBeNull();
    });

    it('should create a task with minimal required fields', async () => {
      const task = await prisma.task.create({
        data: {
          caseId: caseId,
          description: 'シンプルなタスク',
        },
      });

      expect(task).toBeDefined();
      expect(task.caseId).toBe(caseId);
      expect(task.description).toBe('シンプルなタスク');
      expect(task.dueDate).toBeNull();
      expect(task.isCompleted).toBe(false);
      expect(task.isAutoGenerated).toBe(false);
    });

    it('should create a task with assigned user', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'task@example.com',
          name: 'タスク担当者',
        },
      });

      const task = await prisma.task.create({
        data: {
          caseId: caseId,
          description: '担当者付きタスク',
          assignedToId: user.id,
        },
      });

      expect(task.assignedToId).toBe(user.id);
    });

    it('should create a task with auto-generated flag', async () => {
      const task = await prisma.task.create({
        data: {
          caseId: caseId,
          description: '自動生成タスク',
          isAutoGenerated: true,
        },
      });

      expect(task.isAutoGenerated).toBe(true);
    });

    it('should create a completed task', async () => {
      const task = await prisma.task.create({
        data: {
          caseId: caseId,
          description: '完了済みタスク',
          isCompleted: true,
        },
      });

      expect(task.isCompleted).toBe(true);
    });

    it('should fail to create task without case', async () => {
      await expect(
        prisma.task.create({
          data: {
            caseId: 'non-existent-case-id',
            description: 'テストタスク',
          },
        })
      ).rejects.toThrow();
    });

    it('should fail to create task with non-existent assigned user', async () => {
      await expect(
        prisma.task.create({
          data: {
            caseId: caseId,
            description: 'テストタスク',
            assignedToId: 'non-existent-user-id',
          },
        })
      ).rejects.toThrow();
    });
  });

  describe('Read Task', () => {
    let taskId: string;

    beforeEach(async () => {
      const category = await prisma.caseCategory.create({
        data: {
          name: '読取テストカテゴリ',
          roleDefinitions: {},
        },
      });

      const case_ = await prisma.case.create({
        data: {
          name: '読取テスト事件',
          categoryId: category.id,
        },
      });

      const task = await prisma.task.create({
        data: {
          caseId: case_.id,
          description: '読取テストタスク',
          dueDate: new Date('2024-12-31'),
          isCompleted: false,
          isAutoGenerated: true,
        },
      });
      taskId = task.id;
    });

    it('should find task by id', async () => {
      const foundTask = await prisma.task.findUnique({
        where: { id: taskId },
      });

      expect(foundTask).toBeDefined();
      expect(foundTask?.id).toBe(taskId);
      expect(foundTask?.description).toBe('読取テストタスク');
    });

    it('should find task with case relation', async () => {
      const foundTask = await prisma.task.findUnique({
        where: { id: taskId },
        include: {
          case: true,
        },
      });

      expect(foundTask?.case).toBeDefined();
      expect(foundTask?.case.name).toBe('読取テスト事件');
    });

    it('should find task with assigned user relation', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'assigned@example.com',
          name: '割り当てユーザー',
        },
      });

      await prisma.task.update({
        where: { id: taskId },
        data: { assignedToId: user.id },
      });

      const foundTask = await prisma.task.findUnique({
        where: { id: taskId },
        include: {
          assignedTo: true,
        },
      });

      expect(foundTask?.assignedTo).toBeDefined();
      expect(foundTask?.assignedTo?.name).toBe('割り当てユーザー');
    });

    it('should find all tasks', async () => {
      const tasks = await prisma.task.findMany();

      expect(tasks).toHaveLength(1);
      expect(tasks[0].description).toBe('読取テストタスク');
    });

    it('should find tasks by completion status', async () => {
      const completedTasks = await prisma.task.findMany({
        where: { isCompleted: true },
      });

      const incompleteTasks = await prisma.task.findMany({
        where: { isCompleted: false },
      });

      expect(completedTasks).toHaveLength(0);
      expect(incompleteTasks).toHaveLength(1);
    });

    it('should find tasks by auto-generated status', async () => {
      const autoGeneratedTasks = await prisma.task.findMany({
        where: { isAutoGenerated: true },
      });

      const manualTasks = await prisma.task.findMany({
        where: { isAutoGenerated: false },
      });

      expect(autoGeneratedTasks).toHaveLength(1);
      expect(manualTasks).toHaveLength(0);
    });

    it('should find tasks by case', async () => {
      const caseTasks = await prisma.task.findMany({
        where: {
          case: {
            name: '読取テスト事件',
          },
        },
      });

      expect(caseTasks).toHaveLength(1);
      expect(caseTasks[0].description).toBe('読取テストタスク');
    });

    it('should find tasks by due date range', async () => {
      const tasks = await prisma.task.findMany({
        where: {
          dueDate: {
            gte: new Date('2024-01-01'),
            lte: new Date('2024-12-31'),
          },
        },
      });

      expect(tasks).toHaveLength(1);
      expect(tasks[0].description).toBe('読取テストタスク');
    });

    it('should return null for non-existent task', async () => {
      const foundTask = await prisma.task.findUnique({
        where: { id: 'non-existent-id' },
      });

      expect(foundTask).toBeNull();
    });
  });

  describe('Update Task', () => {
    let taskId: string;

    beforeEach(async () => {
      const category = await prisma.caseCategory.create({
        data: {
          name: '更新テストカテゴリ',
          roleDefinitions: {},
        },
      });

      const case_ = await prisma.case.create({
        data: {
          name: '更新テスト事件',
          categoryId: category.id,
        },
      });

      const task = await prisma.task.create({
        data: {
          caseId: case_.id,
          description: '更新前タスク',
          isCompleted: false,
        },
      });
      taskId = task.id;
    });

    it('should update task description', async () => {
      const updatedTask = await prisma.task.update({
        where: { id: taskId },
        data: {
          description: '更新後タスク',
        },
      });

      expect(updatedTask.description).toBe('更新後タスク');
    });

    it('should update task due date', async () => {
      const newDueDate = new Date('2025-01-15');
      const updatedTask = await prisma.task.update({
        where: { id: taskId },
        data: {
          dueDate: newDueDate,
        },
      });

      expect(updatedTask.dueDate).toEqual(newDueDate);
    });

    it('should update task completion status', async () => {
      const updatedTask = await prisma.task.update({
        where: { id: taskId },
        data: {
          isCompleted: true,
        },
      });

      expect(updatedTask.isCompleted).toBe(true);
    });

    it('should update task auto-generated status', async () => {
      const updatedTask = await prisma.task.update({
        where: { id: taskId },
        data: {
          isAutoGenerated: true,
        },
      });

      expect(updatedTask.isAutoGenerated).toBe(true);
    });

    it('should update task assignment', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'assign@example.com',
          name: '割り当てユーザー',
        },
      });

      const updatedTask = await prisma.task.update({
        where: { id: taskId },
        data: {
          assignedToId: user.id,
        },
      });

      expect(updatedTask.assignedToId).toBe(user.id);
    });

    it('should update multiple fields', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'multi@example.com',
          name: '複数更新ユーザー',
        },
      });

      const updatedTask = await prisma.task.update({
        where: { id: taskId },
        data: {
          description: '複数更新タスク',
          dueDate: new Date('2025-02-28'),
          isCompleted: true,
          isAutoGenerated: true,
          assignedToId: user.id,
        },
      });

      expect(updatedTask.description).toBe('複数更新タスク');
      expect(updatedTask.dueDate).toEqual(new Date('2025-02-28'));
      expect(updatedTask.isCompleted).toBe(true);
      expect(updatedTask.isAutoGenerated).toBe(true);
      expect(updatedTask.assignedToId).toBe(user.id);
    });

    it('should fail to update non-existent task', async () => {
      await expect(
        prisma.task.update({
          where: { id: 'non-existent-id' },
          data: { description: '更新' },
        })
      ).rejects.toThrow();
    });
  });

  describe('Delete Task', () => {
    let taskId: string;

    beforeEach(async () => {
      const category = await prisma.caseCategory.create({
        data: {
          name: '削除テストカテゴリ',
          roleDefinitions: {},
        },
      });

      const case_ = await prisma.case.create({
        data: {
          name: '削除テスト事件',
          categoryId: category.id,
        },
      });

      const task = await prisma.task.create({
        data: {
          caseId: case_.id,
          description: '削除テストタスク',
        },
      });
      taskId = task.id;
    });

    it('should delete task by id', async () => {
      const deletedTask = await prisma.task.delete({
        where: { id: taskId },
      });

      expect(deletedTask.id).toBe(taskId);
      expect(deletedTask.description).toBe('削除テストタスク');

      const foundTask = await prisma.task.findUnique({
        where: { id: taskId },
      });
      expect(foundTask).toBeNull();
    });

    it('should fail to delete non-existent task', async () => {
      await expect(
        prisma.task.delete({
          where: { id: 'non-existent-id' },
        })
      ).rejects.toThrow();
    });
  });

  describe('Task Relations', () => {
    it('should find case with tasks', async () => {
      const category = await prisma.caseCategory.create({
        data: {
          name: '案件タスク一覧テストカテゴリ',
          roleDefinitions: {},
        },
      });

      const case_ = await prisma.case.create({
        data: {
          name: '案件タスク一覧テスト事件',
          categoryId: category.id,
        },
      });

      await prisma.task.createMany({
        data: [
          {
            caseId: case_.id,
            description: 'タスク1',
            isCompleted: false,
          },
          {
            caseId: case_.id,
            description: 'タスク2',
            isCompleted: true,
          },
          {
            caseId: case_.id,
            description: 'タスク3',
            isAutoGenerated: true,
          },
        ],
      });

      const caseWithTasks = await prisma.case.findUnique({
        where: { id: case_.id },
        include: {
          tasks: true,
        },
      });

      expect(caseWithTasks?.tasks).toHaveLength(3);
      expect(caseWithTasks?.tasks[0].description).toBe('タスク1');
      expect(caseWithTasks?.tasks[1].description).toBe('タスク2');
      expect(caseWithTasks?.tasks[2].description).toBe('タスク3');
    });

    it('should find user with assigned tasks', async () => {
      const user = await prisma.user.create({
        data: {
          email: 'assigned@example.com',
          name: '割り当てユーザー',
        },
      });

      const category = await prisma.caseCategory.create({
        data: {
          name: 'ユーザータスク一覧テストカテゴリ',
          roleDefinitions: {},
        },
      });

      const case_ = await prisma.case.create({
        data: {
          name: 'ユーザータスク一覧テスト事件',
          categoryId: category.id,
        },
      });

      await prisma.task.createMany({
        data: [
          {
            caseId: case_.id,
            description: '割り当てタスク1',
            assignedToId: user.id,
          },
          {
            caseId: case_.id,
            description: '割り当てタスク2',
            assignedToId: user.id,
          },
        ],
      });

      const userWithTasks = await prisma.user.findUnique({
        where: { id: user.id },
        include: {
          tasks: {
            include: {
              case: true,
            },
          },
        },
      });

      expect(userWithTasks?.tasks).toHaveLength(2);
      expect(userWithTasks?.tasks[0].description).toBe('割り当てタスク1');
      expect(userWithTasks?.tasks[1].description).toBe('割り当てタスク2');
    });
  });
});
